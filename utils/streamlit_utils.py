import datetime
import streamlit as st
import pandas as pd
from google.cloud import bigquery
import requests as pyrequests
import os
import json
import requests as pyrequests  # rename to avoid conflict with google.auth.transport.requests
from streamlit_oauth import OAuth2Component
from config.app_config import USE_LOCAL
import requests as pyrequests
import os
import json
import requests as pyrequests  # rename to avoid conflict with google.auth.transport.requests
from streamlit_oauth import OAuth2Component
from config.app_config import USE_LOCAL

def log_vote_to_bq(client: bigquery.Client, full_table_path: str, vote_type: str, question: str, summary: str):
    """
    Logs user feedback (upvote/downvote) to a specified BigQuery table.

    Args:
        client (bigquery.Client): An initialized BigQuery client.
        full_table_path (str): The full BigQuery table path (e.g., "project.dataset.table").
        vote_type (str): The type of vote ("UP" for üëç, "DOWN" for üëé).
        question (str): The original question asked by the user.
        summary (str): The summary provided by the chatbot.
    """
    user_email = st.session_state.get("user", {}).get("email", "unknown")
    question_id = st.session_state.get("question_id", "unknown")
    user_email = st.session_state.get("user", {}).get("email", "unknown")
    question_id = st.session_state.get("question_id", "unknown")
    rows = [{
        "vote_type": vote_type,
        "question_id": question_id,
        "user_email": user_email,
        "question_id": question_id,
        "user_email": user_email,
        "timestamp": datetime.datetime.utcnow().isoformat()
    }]
    errors = client.insert_rows_json(full_table_path, rows)
    if errors:
        st.error(f"üî¥ Error logging vote to BigQuery: {errors}")

def log_interaction_to_bq(client: bigquery.Client, full_table_path: str, question: str, sql: str, summary: str):
    """
    Logs a user interaction (question, generated SQL, and summary) to a specified BigQuery table.

    Args:
        client (bigquery.Client): An initialized BigQuery client.
        full_table_path (str): The full BigQuery table path (e.g., "project.dataset.table").
        question (str): The original question asked by the user.
        sql (str): The SQL query generated by the chatbot.
        summary (str): The natural language summary provided by the chatbot.
    """
    question_id = st.session_state.get("question_id", "unknown")
    user_email = st.session_state.get("user", {}).get("email", "unknown")
    question_id = st.session_state.get("question_id", "unknown")
    user_email = st.session_state.get("user", {}).get("email", "unknown")
    rows = [{
        "question": question,
        "question_id": question_id,
        "user_email": user_email,
        "question_id": question_id,
        "user_email": user_email,
        "generated_sql": sql,
        "summary": summary,
        "timestamp": datetime.datetime.utcnow().isoformat()
    }]
    errors = client.insert_rows_json(full_table_path, rows)
    if errors:
        st.error(f"üî¥ Error logging interaction to BigQuery: {errors}")

def log_error_to_bq(client: bigquery.Client, full_table_path: str, question: str, sql: str, error_msg: str, attempt: int):
    """
    Logs an error that occurred during SQL generation or BigQuery execution to a specified table.

    Args:
        client (bigquery.Client): An initialized BigQuery client.
        full_table_path (str): The full BigQuery table path (e.g., "project.dataset.table").
        question (str): The original question asked by the user.
        sql (str): The SQL query (if any) that caused the error.
        error_msg (str): The error message.
        attempt (int): The attempt number at which the error occurred.
    """
    rows = [{
        "timestamp": datetime.datetime.utcnow().isoformat(),
        "question": question,
        "generated_sql": sql,
        "error_message": error_msg,
        "attempt": attempt
    }]
    errors = client.insert_rows_json(full_table_path, rows)
    if errors:
        st.error(f"üî¥ Failed to log error to BigQuery: {errors}")

def log_zero_result_to_bq(bq_client: bigquery.Client, table_name: str, question: str, sql: str, attempt_number: int):
    """
    Logs instances where a generated SQL query returned no results to a specified table.

    Args:
        bq_client (bigquery.Client): An initialized BigQuery client.
        table_name (str): The full BigQuery table path (e.g., "project.dataset.table").
        question (str): The original question asked by the user.
        sql (str): The SQL query that returned no results.
        attempt_number (int): The attempt number at which zero results were returned.
    """
    rows_to_insert = [{
        "question": question,
        "sql": sql,
        "attempt_number": attempt_number,
        "timestamp": datetime.datetime.utcnow().isoformat()
    }]
    errors = bq_client.insert_rows_json(table_name, rows_to_insert)
    if errors:
        st.error(f"üî¥ Failed to log zero result to BigQuery: {errors}")



def render_login_block(oauth2, redirect_uri):


    if "user" in st.session_state:
        user_info = st.session_state["user"]
        st.success(f"Welcome, {user_info.get('name', 'triathlete')} üëã")
        st.image(user_info.get("picture", ""), width=80)
        st.markdown(f"**Email:** {user_info.get('email')}")

        if st.button("Logout"):
            del st.session_state["user"]
            st.rerun()
    else:
        # st.markdown("### üîê Sign in to Trilytx")
        # st.markdown("Login to access the chatbot and vote on answers.")
        token = oauth2.authorize_button(
            name="üü¢ Login with Google",
            redirect_uri=redirect_uri,
            scope="openid email profile"
        )

        if token:
            raw_token = token.get("token")
            if raw_token and "access_token" in raw_token:
                response = pyrequests.get(
                    "https://www.googleapis.com/oauth2/v3/userinfo",
                    headers={"Authorization": f"Bearer {raw_token['access_token']}"}
                )
                if response.status_code == 200:
                    user_info = response.json()
                    st.session_state["user"] = user_info
                    st.rerun()
                else:
                    st.error("‚ùå Failed to fetch user info from Google.")
            else:
                st.error("‚ùå OAuth token missing access_token.")
        else:
            st.markdown("""
            <div style="background-color:#e0f0ff;padding:10px;border-radius:10px;text-align:center;">
                üëÜ <strong style="color:black;">Please log in with Google to access full features.</strong>
            </div>
            """, unsafe_allow_html=True)
# config.py or streamlit_utils.py
def get_oauth():
    with open("google_credentials.json") as f:
        creds = json.load(f)["web"]

    oauth2 = OAuth2Component(
        client_id=creds["client_id"],
        client_secret=creds["client_secret"],
        authorize_endpoint=creds["auth_uri"],
        token_endpoint=creds["token_uri"]
    )

    redirect_uri = "https://www.trilytx.com" if not USE_LOCAL else creds["redirect_uris"][1]

    return oauth2, redirect_uri



def render_login_block(oauth2, redirect_uri):


    if "user" in st.session_state:
        user_info = st.session_state["user"]
        st.success(f"Welcome, {user_info.get('name', 'triathlete')} üëã")
        st.image(user_info.get("picture", ""), width=80)
        st.markdown(f"**Email:** {user_info.get('email')}")

        if st.button("Logout"):
            del st.session_state["user"]
            st.rerun()
    else:
        # st.markdown("### üîê Sign in to Trilytx")
        # st.markdown("Login to access the chatbot and vote on answers.")
        token = oauth2.authorize_button(
            name="üü¢ Login with Google",
            redirect_uri=redirect_uri,
            scope="openid email profile"
        )

        if token:
            raw_token = token.get("token")
            if raw_token and "access_token" in raw_token:
                response = pyrequests.get(
                    "https://www.googleapis.com/oauth2/v3/userinfo",
                    headers={"Authorization": f"Bearer {raw_token['access_token']}"}
                )
                if response.status_code == 200:
                    user_info = response.json()
                    st.session_state["user"] = user_info
                    st.rerun()
                else:
                    st.error("‚ùå Failed to fetch user info from Google.")
            else:
                st.error("‚ùå OAuth token missing access_token.")
        else:
            st.markdown("""
            <div style="background-color:#e0f0ff;padding:10px;border-radius:10px;text-align:center;">
                üëÜ <strong style="color:black;">Please log in with Google to access full features.</strong>
            </div>
            """, unsafe_allow_html=True)
# config.py or streamlit_utils.py
def get_oauth():
    with open("google_credentials.json") as f:
        creds = json.load(f)["web"]

    oauth2 = OAuth2Component(
        client_id=creds["client_id"],
        client_secret=os.getenv("GOOGLE_CLIENT_SECRET"),
        authorize_endpoint=creds["auth_uri"],
        token_endpoint=creds["token_uri"]
    )

    redirect_uri = "https://www.trilytx.com" if not USE_LOCAL else creds["redirect_uris"][1]

    return oauth2, redirect_uri
